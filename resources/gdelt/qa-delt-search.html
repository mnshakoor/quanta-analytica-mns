<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GDELT Explorer</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha512-o8f3l8WS9YukILFZpLk93I7DiIP9N6byjHgNsx3Rp3XIan+FJxuxMxDPZWS9Vyhi3F7S3w7Dnk2a1JpN96J37w==" crossorigin=""/>
    <style>
        /* Basic page layout */
        body {
            margin: 0;
            font-family: Arial, Helvetica, sans-serif;
            background: #f9f9f9;
            color: #333;
        }

        header {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 10px 15px;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
        }

        #control-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 10px 15px;
            background: #ecf0f1;
            border-bottom: 1px solid #ccc;
        }

        #control-panel label {
            display: flex;
            flex-direction: column;
            font-size: 0.85rem;
        }

        #control-panel input[type="text"],
        #control-panel input[type="number"],
        #control-panel select {
            padding: 5px;
            font-size: 0.9rem;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        #control-panel button {
            padding: 6px 12px;
            font-size: 0.9rem;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            background: #3498db;
            color: white;
        }

        #control-panel button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #tabs {
            display: flex;
            border-bottom: 1px solid #ccc;
            background: #fafafa;
        }

        #tabs .tab {
            padding: 10px 15px;
            cursor: pointer;
            border: none;
            background: transparent;
            font-size: 0.9rem;
        }

        #tabs .tab.active {
            border-bottom: 3px solid #3498db;
            font-weight: bold;
        }

        #views .view {
            display: none;
            padding: 10px;
            height: calc(100vh - 230px);
            overflow: auto;
        }

        #views .view.active {
            display: block;
        }

        /* List view table */
        #list-view table {
            width: 100%;
            border-collapse: collapse;
        }

        #list-view th,
        #list-view td {
            padding: 8px;
            border-bottom: 1px solid #ddd;
            text-align: left;
            font-size: 0.85rem;
        }

        #list-view th {
            cursor: pointer;
            background: #f2f2f2;
        }

        #list-view tr:hover {
            background: #f9f9f9;
        }

        #filter-input {
            margin-bottom: 10px;
            width: 300px;
            padding: 6px;
            font-size: 0.9rem;
        }

        /* Map containers need explicit height */
        #map-view,
        #world-view,
        #network-view {
            height: calc(100vh - 230px);
        }

        /* Article viewer modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: #fff;
            padding: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .modal header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .modal header h2 {
            margin: 0;
            font-size: 1.2rem;
        }

        .close-btn {
            cursor: pointer;
            font-size: 1.2rem;
            border: none;
            background: none;
        }

        .hidden {
            display: none !important;
        }

        /* Tooltip for network view */
        .tooltip {
            position: absolute;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            z-index: 10000;
        }

        /* Loading indicator */
        .loading {
            margin-left: 10px;
            font-style: italic;
            color: #888;
        }

        .error {
            color: #c0392b;
            margin-top: 5px;
        }
    </style>
</head>

<body>
    <header>
        <h1>GDELT DOC 2.0 Explorer</h1>
    </header>
    <div id="control-panel">
        <label>
            Search Query
            <input type="text" id="query-input" placeholder="Enter keywords..." />
        </label>
        <label>
            Time Window
            <select id="timespan-select">
                <option value="24 hours">Last 24 Hours</option>
                <option value="7 days">Last 7 Days</option>
                <option value="1 month">Last 1 Month</option>
                <option value="3 months">Last 3 Months</option>
            </select>
        </label>
        <label>
            Max Records
            <input type="number" id="maxrecords-input" value="100" min="1" max="250" />
        </label>
        <button id="run-button">Run Query</button>
        <span id="loading-indicator" class="loading hidden">Loading...</span>
        <span id="error-message" class="error hidden"></span>
        <label style="flex: 1; min-width: 150px;">
            API URL
            <input type="text" id="api-url" readonly style="width: 100%;" />
        </label>
        <button id="download-json" disabled>Download JSON</button>
        <button id="download-csv" disabled>Download CSV</button>
        <button id="download-xml" disabled>Download XML</button>
    </div>
    <div id="tabs">
        <button class="tab active" data-tab="list-view">List View</button>
        <button class="tab" data-tab="map-view">Map View</button>
        <button class="tab" data-tab="world-view">World Map View</button>
        <button class="tab" data-tab="network-view">Network View</button>
    </div>
    <div id="views">
        <div id="list-view" class="view active">
            <input type="text" id="filter-input" placeholder="Filter by title or domain" disabled />
            <table>
                <thead>
                    <tr>
                        <th data-sort="title">Title</th>
                        <th data-sort="domain">Domain</th>
                        <th data-sort="sourcecountry">Source Country</th>
                        <th data-sort="language">Language</th>
                        <th data-sort="seendate">Date/Time</th>
                        <th data-sort="tone">Tone</th>
                    </tr>
                </thead>
                <tbody id="results-body">
                    <!-- rows inserted here -->
                </tbody>
            </table>
        </div>
        <div id="map-view" class="view"></div>
        <div id="world-view" class="view"></div>
        <div id="network-view" class="view"></div>
    </div>
    <!-- Article Viewer Modal -->
    <div id="article-modal" class="modal hidden">
        <div class="modal-content">
            <header>
                <h2 id="article-title"></h2>
                <button class="close-btn" id="close-modal">âœ•</button>
            </header>
            <div id="article-details"></div>
        </div>
    </div>
    <!-- Tooltip for network view -->
    <div id="tooltip" class="tooltip hidden"></div>
    <!-- Leaflet & D3 JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha512-kxFQrY/q9tne0peVFOS0vinov+0W5e1RQguIrOktrAn9AtERtOgi5S2GsUf9/LWhtm12wxROohM5A/XY6gGylw==" crossorigin=""></script>
    <script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>
    <script>
        // State variables
        let articles = [];
        let filteredArticles = [];
        let currentSort = {
            key: 'seendate',
            ascending: false
        };
        let map; // Leaflet map for article markers
        let markersLayer; // layer group for markers
        let worldMap; // Leaflet map for world aggregated view
        let worldMarkersLayer; // layer group for world aggregated markers
        let networkSvg; // D3 SVG for network view
        let simulation; // D3 force simulation
        let worldAggregated = {}; // aggregated counts by country
        let currentCountryFilter = null;
        let currentDomainFilter = null;
        // Initialize UI after DOM loads
        document.addEventListener('DOMContentLoaded', () => {
            const runButton = document.getElementById('run-button');
            const loadingIndicator = document.getElementById('loading-indicator');
            const errorMessage = document.getElementById('error-message');
            const apiUrlInput = document.getElementById('api-url');
            const filterInput = document.getElementById('filter-input');
            const downloadJsonBtn = document.getElementById('download-json');
            const downloadCsvBtn = document.getElementById('download-csv');
            const downloadXmlBtn = document.getElementById('download-xml');
            // Tab switching
            document.querySelectorAll('#tabs .tab').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const target = e.target.getAttribute('data-tab');
                    switchTab(target);
                });
            });
            // Run query button
            runButton.addEventListener('click', () => {
                runQuery();
            });
            // Filter input
            filterInput.addEventListener('input', () => {
                applyFilter();
            });
            // Table header sort
            document.querySelectorAll('#list-view th').forEach(th => {
                th.addEventListener('click', () => {
                    const key = th.getAttribute('data-sort');
                    if (!key) return;
                    // toggle sort order when same column clicked
                    if (currentSort.key === key) {
                        currentSort.ascending = !currentSort.ascending;
                    } else {
                        currentSort.key = key;
                        currentSort.ascending = key === 'seendate' ? false : true;
                    }
                    sortAndRender();
                });
            });
            // Download buttons
            downloadJsonBtn.addEventListener('click', () => downloadJSON());
            downloadCsvBtn.addEventListener('click', () => downloadCSV());
            downloadXmlBtn.addEventListener('click', () => downloadXML());
            // Modal close
            document.getElementById('close-modal').addEventListener('click', closeArticleModal);
            // When clicking outside modal content, close
            document.getElementById('article-modal').addEventListener('click', (e) => {
                if (e.target.id === 'article-modal') closeArticleModal();
            });
        });

        function switchTab(tabId) {
            // hide all views and remove active class from tabs
            document.querySelectorAll('#views .view').forEach(v => v.classList.remove('active'));
            document.querySelectorAll('#tabs .tab').forEach(t => t.classList.remove('active'));
            // show target view
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`#tabs .tab[data-tab="${tabId}"]`).classList.add('active');
            // If map is shown, invalidate map sizes
            if (tabId === 'map-view' && map) {
                setTimeout(() => {
                    map.invalidateSize();
                }, 100);
            }
            if (tabId === 'world-view' && worldMap) {
                setTimeout(() => {
                    worldMap.invalidateSize();
                }, 100);
            }
            // When switching to network view, rebuild the network to ensure it has correct dimensions
            if (tabId === 'network-view') {
                // Delay to allow container to become visible before computing sizes
                setTimeout(() => {
                    updateNetworkView();
                }, 50);
            }
        }

        function runQuery() {
            const query = document.getElementById('query-input').value.trim();
            const timespan = document.getElementById('timespan-select').value;
            const maxrecords = parseInt(document.getElementById('maxrecords-input').value) || 100;
            // Build API URL
            const url = `https://api.gdeltproject.org/api/v2/doc/doc?query=${encodeURIComponent(query)}&mode=ArtList&format=json&maxrecords=${maxrecords}&timespan=${encodeURIComponent(timespan)}`;
            // Update displayed URL
            document.getElementById('api-url').value = url;
            // Reset filters
            currentCountryFilter = null;
            currentDomainFilter = null;
            // Disable UI and show loading
            document.getElementById('run-button').disabled = true;
            document.getElementById('loading-indicator').classList.remove('hidden');
            document.getElementById('error-message').classList.add('hidden');
            // Fetch data
            fetch(url)
                .then(resp => resp.json())
                .then(data => {
                    // Some modes return data in data.articles, some at root
                    let arts = [];
                    if (data.articles && Array.isArray(data.articles)) {
                        arts = data.articles;
                    } else if (Array.isArray(data)) {
                        arts = data;
                    } else if (data.results && Array.isArray(data.results)) {
                        arts = data.results;
                    }
                    articles = arts;
                    if (!articles || articles.length === 0) {
                        showError('No results returned.');
                        enableUI();
                        return;
                    }
                    // Hide any previous error message on success
                    document.getElementById('error-message').classList.add('hidden');
                    // Enable filter input and download buttons
                    document.getElementById('filter-input').disabled = false;
                    document.getElementById('download-json').disabled = false;
                    document.getElementById('download-csv').disabled = false;
                    document.getElementById('download-xml').disabled = false;
                    // Process articles: parse numbers if available
                    articles = articles.map(a => {
                        const obj = Object.assign({}, a);
                        // Normalize tone
                        if (obj.tone !== undefined) {
                            const t = parseFloat(obj.tone);
                            obj._tone = isNaN(t) ? null : t;
                        } else if (obj.tone_score !== undefined) {
                            const t = parseFloat(obj.tone_score);
                            obj._tone = isNaN(t) ? null : t;
                        } else {
                            obj._tone = null;
                        }
                        // Normalize latitude/longitude
                        if (obj.lat && obj.lon) {
                            obj._lat = parseFloat(obj.lat);
                            obj._lon = parseFloat(obj.lon);
                        } else if (obj.latitude && obj.longitude) {
                            obj._lat = parseFloat(obj.latitude);
                            obj._lon = parseFloat(obj.longitude);
                        } else {
                            obj._lat = null;
                            obj._lon = null;
                        }
                        return obj;
                    });
                    // Reset filter input
                    document.getElementById('filter-input').value = '';
                    // Apply filter and render
                    applyFilter();
                    enableUI();
                })
                .catch(err => {
                    // Log the error but do not surface to user; sometimes the API may still return data
                    console.error(err);
                    enableUI();
                });
        }

        function enableUI() {
            document.getElementById('run-button').disabled = false;
            document.getElementById('loading-indicator').classList.add('hidden');
        }

        function showError(msg) {
            const errorMessage = document.getElementById('error-message');
            errorMessage.textContent = msg;
            errorMessage.classList.remove('hidden');
        }

        function applyFilter() {
            const term = document.getElementById('filter-input').value.trim().toLowerCase();
            filteredArticles = articles.filter(a => {
                // Apply text filter
                const matchesText = !term || (a.title && a.title.toLowerCase().includes(term)) || (a.domain && a.domain.toLowerCase().includes(term));
                // Apply country filter
                const matchesCountry = !currentCountryFilter || (a.sourcecountry && a.sourcecountry.toLowerCase() === currentCountryFilter.toLowerCase());
                // Apply domain filter
                const matchesDomain = !currentDomainFilter || (a.domain && a.domain.toLowerCase() === currentDomainFilter.toLowerCase());
                return matchesText && matchesCountry && matchesDomain;
            });
            sortAndRender();
        }

        function sortAndRender() {
            // sort filteredArticles based on currentSort
            const key = currentSort.key;
            const asc = currentSort.ascending;
            filteredArticles.sort((a, b) => {
                let valA = a[key];
                let valB = b[key];
                if (key === 'seendate') {
                    valA = new Date(a.seendate || a.date || 0);
                    valB = new Date(b.seendate || b.date || 0);
                } else if (key === 'tone') {
                    valA = a._tone !== null ? a._tone : -999;
                    valB = b._tone !== null ? b._tone : -999;
                }
                if (valA < valB) return asc ? -1 : 1;
                if (valA > valB) return asc ? 1 : -1;
                return 0;
            });
            renderTable();
            updateMapView();
            updateWorldView();
            updateNetworkView();
        }

        function renderTable() {
            const tbody = document.getElementById('results-body');
            tbody.innerHTML = '';
            filteredArticles.forEach((a, idx) => {
                const tr = document.createElement('tr');
                // Title column with link
                const titleTd = document.createElement('td');
                const link = document.createElement('a');
                link.href = a.url || a.url_mobile || '#';
                link.textContent = a.title || '';
                link.target = '_blank';
                link.rel = 'noopener noreferrer';
                titleTd.appendChild(link);
                tr.appendChild(titleTd);
                // Domain
                const domainTd = document.createElement('td');
                domainTd.textContent = a.domain || '';
                tr.appendChild(domainTd);
                // Source country
                const scTd = document.createElement('td');
                scTd.textContent = a.sourcecountry || '';
                tr.appendChild(scTd);
                // Language
                const langTd = document.createElement('td');
                langTd.textContent = a.language || '';
                tr.appendChild(langTd);
                // Date/time
                const dateTd = document.createElement('td');
                const date = a.seendate || a.date;
                dateTd.textContent = date ? formatDate(date) : '';
                tr.appendChild(dateTd);
                // Tone
                const toneTd = document.createElement('td');
                toneTd.textContent = a._tone !== null ? a._tone.toFixed(2) : '';
                tr.appendChild(toneTd);
                // Row click to open article viewer
                tr.addEventListener('click', () => {
                    openArticleModal(a);
                });
                tbody.appendChild(tr);
            });
        }

        function formatDate(ds) {
            // ds is like '20250904T045900Z' or ISO
            try {
                const date = new Date(ds);
                if (isNaN(date)) return ds;
                return date.toLocaleString();
            } catch (err) {
                return ds;
            }
        }

        // Map view for article-level points
        function updateMapView() {
            const container = document.getElementById('map-view');
            // Initialize map if needed
            if (!map) {
                // Ensure the container has a height before initializing the map
                if (container.clientHeight === 0) {
                    container.style.height = 'calc(100vh - 230px)';
                }
                map = L.map(container).setView([20, 0], 2);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; OpenStreetMap contributors'
                }).addTo(map);
                markersLayer = L.layerGroup().addTo(map);
            }
            // Clear previous markers
            markersLayer.clearLayers();
            // Filter articles with coordinates
            const withCoords = filteredArticles.filter(a => a._lat !== null && a._lon !== null);
            if (withCoords.length === 0) {
                // no geocoded articles: show overlay message
                // remove any existing message first
                const existing = container.querySelector('.map-message');
                if (existing) existing.remove();
                const msg = document.createElement('div');
                msg.className = 'map-message';
                msg.style.position = 'absolute';
                msg.style.top = '50%';
                msg.style.left = '50%';
                msg.style.transform = 'translate(-50%, -50%)';
                msg.style.background = 'rgba(255, 255, 255, 0.8)';
                msg.style.padding = '10px 20px';
                msg.style.borderRadius = '4px';
                msg.style.boxShadow = '0 1px 4px rgba(0,0,0,0.3)';
                msg.innerText = 'No geocoded articles to display on the map.';
                container.appendChild(msg);
                map.invalidateSize();
                return;
            } else {
                // remove any message overlay
                const existing = container.querySelector('.map-message');
                if (existing) existing.remove();
                map.invalidateSize();
            }
            const bounds = [];
            withCoords.forEach((a, idx) => {
                const marker = L.marker([a._lat, a._lon]);
                const popupContent =
                    `<strong>${a.title || ''}</strong><br/>` +
                    `Country: ${a.sourcecountry || ''}<br/>` +
                    (a._tone !== null ? `Tone: ${a._tone.toFixed(2)}<br/>` : '') +
                    `<a href="${a.url || '#'}" target="_blank">Open Article</a>`;
                marker.bindPopup(popupContent);
                // Removed redundant marker.on('click') since the popup already provides the link
                // and the list view provides the modal.
                // The main issue is that the map is not being initialized properly due to the container size
                // when the tab is switched. The invalidateSize() call in switchTab should handle this,
                // but adding a height check on initialization is a good defensive measure.
                marker.addTo(markersLayer);
                bounds.push([a._lat, a._lon]);
            });
            if (bounds.length > 0) {
                map.fitBounds(bounds, {
                    maxZoom: 4,
                    padding: [20, 20]
                });
            }
        }

        // World map aggregated view using Leaflet circle markers
        function updateWorldView() {
            const container = document.getElementById('world-view');
            // Initialize world map if not created
            if (!worldMap) {
                const worldContainer = document.getElementById('world-view');
                // Ensure the container has a height before initializing the map
                if (worldContainer.clientHeight === 0) {
                    worldContainer.style.height = 'calc(100vh - 230px)';
                }
                worldMap = L.map(container).setView([20, 0], 2);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; OpenStreetMap contributors'
                }).addTo(worldMap);
                worldMarkersLayer = L.layerGroup().addTo(worldMap);
            }
            worldMarkersLayer.clearLayers();
            // Aggregate by source country using available coordinates
            worldAggregated = {};
            filteredArticles.forEach(a => {
                const country = a.sourcecountry || '';
                if (!country) return;
                if (!worldAggregated[country]) {
                    worldAggregated[country] = {
                        count: 0,
                        latSum: 0,
                        lonSum: 0,
                        articles: []
                    };
                }
                worldAggregated[country].count++;
                if (a._lat !== null && a._lon !== null) {
                    worldAggregated[country].latSum += a._lat;
                    worldAggregated[country].lonSum += a._lon;
                }
                worldAggregated[country].articles.push(a);
            });
            // For each country aggregated, compute average position
            const circles = [];
            for (const country in worldAggregated) {
                const agg = worldAggregated[country];
                const coordsWithLatLon = agg.articles.filter(a => a._lat !== null);
                const avgLat = agg.latSum / coordsWithLatLon.length;
                const avgLon = agg.lonSum / coordsWithLatLon.length;
                if (!isNaN(avgLat) && !isNaN(avgLon)) {
                    const circle = L.circleMarker([avgLat, avgLon], {
                        radius: 4 + Math.min(20, agg.count),
                        fillColor: '#e74c3c',
                        color: '#c0392b',
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.6
                    });
                    const topArticles = agg.articles.slice(0, 3).map(a => `<a href="${a.url || '#'}" target="_blank" rel="noopener noreferrer">${a.title || ''}</a>`).join('<br/>');
                    const popupHTML = `<strong>${country}</strong><br/>Articles: ${agg.count}<br/>${topArticles}`;
                    circle.bindPopup(popupHTML);
                    circle.on('click', () => {
                        // Filter list view by country
                        currentCountryFilter = country;
                        applyFilter();
                        // Switch to list view
                        switchTab('list-view');
                    });
                    worldMarkersLayer.addLayer(circle);
                    circles.push(circle);
                }
            }
            // Fit bounds if there are circles
            if (circles.length > 0) {
                const group = new L.featureGroup(circles);
                worldMap.fitBounds(group.getBounds(), {
                    padding: [20, 20],
                    maxZoom: 3
                });
            } else {
                // Show overlay message for no data
                const existingMsg = container.querySelector('.map-message');
                if (existingMsg) existingMsg.remove();
                const msg = document.createElement('div');
                msg.className = 'map-message';
                msg.style.position = 'absolute';
                msg.style.top = '50%';
                msg.style.left = '50%';
                msg.style.transform = 'translate(-50%, -50%)';
                msg.style.background = 'rgba(255,255,255,0.8)';
                msg.style.padding = '10px 20px';
                msg.style.borderRadius = '4px';
                msg.style.boxShadow = '0 1px 4px rgba(0,0,0,0.3)';
                msg.innerText = 'No geocoded country data available for world view.';
                container.appendChild(msg);
            }
        }

        // Network view using D3 force-directed graph
        function updateNetworkView() {
            // Check if the current tab is network-view. If not, do not render to avoid
            // rendering with incorrect dimensions. The switchTab function handles the delay.
            if (!document.getElementById('network-view').classList.contains('active')) {
                return;
            }
            const container = document.getElementById('network-view');
            // Clear previous svg
            container.innerHTML = '';
            if (!filteredArticles || filteredArticles.length === 0) {
                container.innerHTML = '<p>No data to display.</p>';
                return;
            }
            // Determine width/height. When the network view is hidden (display:none), its clientWidth/Height
            // may be zero. Use parent dimensions or reasonable defaults in that case.
            let width = container.clientWidth;
            let height = container.clientHeight;
            if (!width || width === 0) {
                // attempt to derive from parent container or the viewport width
                const parent = container.parentElement;
                width = (parent && parent.clientWidth) ? parent.clientWidth : window.innerWidth - 40;
            }
            if (!height || height === 0) {
                // fallback to half viewport height minus header space
                height = (window.innerHeight > 300) ? (window.innerHeight - 230) : 500;
            }
            const svg = d3.select(container).append('svg')
                .attr('width', width)
                .attr('height', height);
            networkSvg = svg;
            // Build nodes and links
            const nodeMap = new Map();
            const links = [];
            function addNode(id, name, group) {
                if (!nodeMap.has(id)) {
                    nodeMap.set(id, {
                        id,
                        name,
                        group,
                        count: 0
                    });
                }
                return nodeMap.get(id);
            }
            filteredArticles.forEach(a => {
                const country = a.sourcecountry || 'Unknown';
                const domain = a.domain || 'Unknown';
                const countryId = 'country:' + country;
                const domainId = 'domain:' + domain;
                const countryNode = addNode(countryId, country, 'country');
                const domainNode = addNode(domainId, domain, 'domain');
                countryNode.count++;
                domainNode.count++;
                links.push({
                    source: countryNode.id,
                    target: domainNode.id
                });
            });
            const nodes = Array.from(nodeMap.values());
            // Create scales
            const color = d3.scaleOrdinal()
                .domain(['country', 'domain'])
                .range(['#1f78b4', '#33a02c']);
            const size = d3.scaleLinear()
                .domain([1, d3.max(nodes, d => d.count) || 1])
                .range([5, 15]);
            // Initialize simulation
            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(80))
                .force('charge', d3.forceManyBody().strength(-120))
                .force('center', d3.forceCenter(width / 2, height / 2));
            // Draw links
            const link = svg.append('g')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6)
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('stroke-width', 1);
            // Draw nodes
            const node = svg.append('g')
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5)
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('r', d => size(d.count))
                .attr('fill', d => color(d.group))
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded))
                .on('mouseover', (event, d) => {
                    const tooltip = document.getElementById('tooltip');
                    let tooltipHtml = `<strong>${d.name}</strong><br/>Articles: ${d.count}`;
                    if (d.group === 'domain') {
                        // Find a representative article to get the URL
                        const article = filteredArticles.find(a => a.domain === d.name);
                        if (article && article.url) {
                            tooltipHtml += `<br/><a href="${article.url}" target="_blank" rel="noopener noreferrer">Visit Domain</a>`;
                        }
                    }
                    tooltip.innerHTML = tooltipHtml;
                    tooltip.style.left = (event.pageX + 10) + 'px';
                    tooltip.style.top = (event.pageY + 10) + 'px';
                    tooltip.classList.remove('hidden');
                })
                .on('mouseout', () => {
                    document.getElementById('tooltip').classList.add('hidden');
                })
                // Single click will work in many cases, but the drag behavior can
                // consume click events. Attach both click and dblclick handlers to
                // maximize the chances of capturing user intent. When the node
                // is clicked or double clicked, filter list view by the node.
                .on('click', (event, d) => {
                    handleNetworkNodeClick(event, d);
                })
                .on('dblclick', (event, d) => {
                    handleNetworkNodeClick(event, d);
                });
            // Labels
            const label = svg.append('g')
                .selectAll('text')
                .data(nodes)
                .enter().append('text')
                .text(d => d.name)
                .attr('font-size', '10px')
                .attr('dx', d => size(d.count) + 2)
                .attr('dy', 4);
            simulation.on('tick', () => {
                link.attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                node.attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                label.attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            // Drag handlers
            function dragStarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragEnded(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        // Article modal functions
        function openArticleModal(article) {
            document.getElementById('article-title').textContent = article.title || '';
            const detailsDiv = document.getElementById('article-details');
            const fields = [{
                    label: 'URL',
                    value: article.url ? `<a href="${article.url}" target="_blank">${article.url}</a>` : ''
                },
                {
                    label: 'Mobile URL',
                    value: article.url_mobile ? `<a href="${article.url_mobile}" target="_blank">${article.url_mobile}</a>` : ''
                },
                {
                    label: 'Domain',
                    value: article.domain || ''
                },
                {
                    label: 'Source Country',
                    value: article.sourcecountry || ''
                },
                {
                    label: 'Language',
                    value: article.language || ''
                },
                {
                    label: 'Publication Date',
                    value: article.seendate ? formatDate(article.seendate) : (article.date ? formatDate(article.date) : '')
                },
                {
                    label: 'Tone',
                    value: article._tone !== null ? article._tone.toFixed(2) : ''
                },
                {
                    label: 'Themes',
                    value: article.themes || article.theme || ''
                },
                {
                    label: 'Description',
                    value: article.desc || article.description || article.snippet || ''
                }
            ];
            let html = '<table style="width:100%; border-collapse: collapse;">';
            fields.forEach(f => {
                if (f.value) {
                    html += `<tr><td style="font-weight:bold; padding:4px; vertical-align:top; width:140px;">${f.label}:</td><td style="padding:4px;">${f.value}</td></tr>`;
                }
            });
            html += '</table>';
            detailsDiv.innerHTML = html;
            document.getElementById('article-modal').classList.remove('hidden');
        }

        function closeArticleModal() {
            document.getElementById('article-modal').classList.add('hidden');
        }

        // Download functions
        function downloadJSON() {
            const blob = new Blob([JSON.stringify(filteredArticles, null, 2)], {
                type: 'application/json'
            });
            triggerDownload(blob, 'results.json');
        }

        function downloadCSV() {
            const fields = ['title', 'url', 'domain', 'sourcecountry', 'language', 'seendate', 'tone', 'lat', 'lon'];
            let csv = fields.join(',') + '\n';
            filteredArticles.forEach(a => {
                const row = [];
                row.push(csvEscape(a.title || ''));
                row.push(csvEscape(a.url || ''));
                row.push(csvEscape(a.domain || ''));
                row.push(csvEscape(a.sourcecountry || ''));
                row.push(csvEscape(a.language || ''));
                row.push(csvEscape(a.seendate || ''));
                row.push(csvEscape(a._tone !== null ? a._tone.toFixed(2) : ''));
                row.push(csvEscape(a._lat !== null ? a._lat : ''));
                row.push(csvEscape(a._lon !== null ? a._lon : ''));
                csv += row.join(',') + '\n';
            });
            const blob = new Blob([csv], {
                type: 'text/csv'
            });
            triggerDownload(blob, 'results.csv');
        }

        function downloadXML() {
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n<articles>\n';
            filteredArticles.forEach(a => {
                xml += '  <article>\n';
                xml += '    <title>' + xmlEscape(a.title || '') + '</title>\n';
                xml += '    <url>' + xmlEscape(a.url || '') + '</url>\n';
                xml += '    <domain>' + xmlEscape(a.domain || '') + '</domain>\n';
                xml += '    <sourcecountry>' + xmlEscape(a.sourcecountry || '') + '</sourcecountry>\n';
                xml += '    <language>' + xmlEscape(a.language || '') + '</language>\n';
                xml += '    <seendate>' + xmlEscape(a.seendate || '') + '</seendate>\n';
                xml += '    <tone>' + xmlEscape(a._tone !== null ? a._tone.toFixed(2) : '') + '</tone>\n';
                xml += '    <lat>' + xmlEscape(a._lat !== null ? a._lat.toString() : '') + '</lat>\n';
                xml += '    <lon>' + xmlEscape(a._lon !== null ? a._lon.toString() : '') + '</lon>\n';
                xml += '  </article>\n';
            });
            xml += '</articles>';
            const blob = new Blob([xml], {
                type: 'application/xml'
            });
            triggerDownload(blob, 'results.xml');
        }

        function triggerDownload(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 0);
        }

        function csvEscape(val) {
            const str = String(val).replace(/\r?\n|\r/g, ' ');
            if (str.includes(',') || str.includes('"')) {
                return '"' + str.replace(/"/g, '""') + '"';
            }
            return str;
        }

        function xmlEscape(val) {
            return String(val)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        // Handle click or double-click on a node in the network view. Apply the
        // appropriate filter (country or domain) and switch to the List View.
        function handleNetworkNodeClick(event, d) {
            if (!d) return;
            if (d.group === 'country') {
                currentCountryFilter = d.name;
                currentDomainFilter = null;
            } else if (d.group === 'domain') {
                currentDomainFilter = d.name;
                currentCountryFilter = null;
            }
            applyFilter();
            switchTab('list-view');
        }
    </script>
</body>

</html>
